"""
This file is meant to analyze the output, generated by the biLouvain algorithm.
"""
import os
import matplotlib.pyplot as plt

output_files = os.listdir("output")

for file_name in output_files:
    if file_name[-21:] == "ResultsModularity.txt":
        "ResultsCt0p0001Cp0p001_ResultsModularity.txt"

# TODO: modularity uitlezen

header = ["Iteration cutoff", "Phase cutoff", "Murata+ Modularity", "Willen we hier nog meer?"]
output_data = [[0.01, 0.0, 0.4555, "iets ofzo"], [0.01, 0.001, 0.3955, "iets ofzo"], [0.025, 0.0, 0.5842, "iets ofzo"],
               [0.025, 0.001, 0.4842, "iets ofzo"]] # Iedere index in output_data heeft de informatie van de header, nu met mock data


#%% Graphs %%#
print(list(enumerate(header))) # zodat je makkelijk kan zien welke index je nodig hebt


# Given a phase_cutoff, make a line graph with the iteration cutoff on the x-axis, and Murata+ on the y-axis.
def make_line_plot(phase_cutoff: float) -> None:
    # Filter to keep only the data with given phase cutoff.
    filtered_data = list(filter(lambda item: (item[1] == phase_cutoff), output_data))
    # @Thijs: wat gaat hier mis? Hij neemt bij de list comprehension alleen de eerste x_data, en y_data blijft leeg.
    x_data = [item[0] for item in filtered_data]
    print(x_data)
    y_data = [item[2] for item in filtered_data]
    print(y_data)
    plt.plot(x_data, y_data)
    plt.xlabel("Iteration cutoff")
    plt.ylabel("Murata+ modularity")
    plt.title("Murata+ modularity per iteration cutoff, with phase cutoff of " + str(phase_cutoff))
    plt.show()


# Graph 1: phase cutoff = 0.0
make_line_plot(0.0)

# Graph 2: phase cutoff = 0.001
make_line_plot(0.001)

#%% LaTeX Table %%#

